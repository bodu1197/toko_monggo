revoke insert on table "public"."access_logs" from "PUBLIC";

revoke delete on table "public"."access_logs" from "anon";

revoke insert on table "public"."access_logs" from "anon";

revoke references on table "public"."access_logs" from "anon";

revoke select on table "public"."access_logs" from "anon";

revoke trigger on table "public"."access_logs" from "anon";

revoke truncate on table "public"."access_logs" from "anon";

revoke update on table "public"."access_logs" from "anon";

revoke delete on table "public"."access_logs" from "authenticated";

revoke insert on table "public"."access_logs" from "authenticated";

revoke references on table "public"."access_logs" from "authenticated";

revoke select on table "public"."access_logs" from "authenticated";

revoke trigger on table "public"."access_logs" from "authenticated";

revoke truncate on table "public"."access_logs" from "authenticated";

revoke update on table "public"."access_logs" from "authenticated";

revoke delete on table "public"."access_logs" from "service_role";

revoke insert on table "public"."access_logs" from "service_role";

revoke references on table "public"."access_logs" from "service_role";

revoke select on table "public"."access_logs" from "service_role";

revoke trigger on table "public"."access_logs" from "service_role";

revoke truncate on table "public"."access_logs" from "service_role";

revoke update on table "public"."access_logs" from "service_role";

revoke delete on table "public"."categories" from "anon";

revoke insert on table "public"."categories" from "anon";

revoke references on table "public"."categories" from "anon";

revoke select on table "public"."categories" from "anon";

revoke trigger on table "public"."categories" from "anon";

revoke truncate on table "public"."categories" from "anon";

revoke update on table "public"."categories" from "anon";

revoke delete on table "public"."categories" from "authenticated";

revoke insert on table "public"."categories" from "authenticated";

revoke references on table "public"."categories" from "authenticated";

revoke select on table "public"."categories" from "authenticated";

revoke trigger on table "public"."categories" from "authenticated";

revoke truncate on table "public"."categories" from "authenticated";

revoke update on table "public"."categories" from "authenticated";

revoke delete on table "public"."categories" from "service_role";

revoke insert on table "public"."categories" from "service_role";

revoke references on table "public"."categories" from "service_role";

revoke select on table "public"."categories" from "service_role";

revoke trigger on table "public"."categories" from "service_role";

revoke truncate on table "public"."categories" from "service_role";

revoke update on table "public"."categories" from "service_role";

revoke delete on table "public"."favorites" from "anon";

revoke insert on table "public"."favorites" from "anon";

revoke references on table "public"."favorites" from "anon";

revoke select on table "public"."favorites" from "anon";

revoke trigger on table "public"."favorites" from "anon";

revoke truncate on table "public"."favorites" from "anon";

revoke update on table "public"."favorites" from "anon";

revoke delete on table "public"."favorites" from "authenticated";

revoke insert on table "public"."favorites" from "authenticated";

revoke references on table "public"."favorites" from "authenticated";

revoke select on table "public"."favorites" from "authenticated";

revoke trigger on table "public"."favorites" from "authenticated";

revoke truncate on table "public"."favorites" from "authenticated";

revoke update on table "public"."favorites" from "authenticated";

revoke delete on table "public"."favorites" from "service_role";

revoke insert on table "public"."favorites" from "service_role";

revoke references on table "public"."favorites" from "service_role";

revoke select on table "public"."favorites" from "service_role";

revoke trigger on table "public"."favorites" from "service_role";

revoke truncate on table "public"."favorites" from "service_role";

revoke update on table "public"."favorites" from "service_role";

revoke delete on table "public"."product_comments" from "anon";

revoke insert on table "public"."product_comments" from "anon";

revoke references on table "public"."product_comments" from "anon";

revoke select on table "public"."product_comments" from "anon";

revoke trigger on table "public"."product_comments" from "anon";

revoke truncate on table "public"."product_comments" from "anon";

revoke update on table "public"."product_comments" from "anon";

revoke delete on table "public"."product_comments" from "authenticated";

revoke insert on table "public"."product_comments" from "authenticated";

revoke references on table "public"."product_comments" from "authenticated";

revoke select on table "public"."product_comments" from "authenticated";

revoke trigger on table "public"."product_comments" from "authenticated";

revoke truncate on table "public"."product_comments" from "authenticated";

revoke update on table "public"."product_comments" from "authenticated";

revoke delete on table "public"."product_comments" from "service_role";

revoke insert on table "public"."product_comments" from "service_role";

revoke references on table "public"."product_comments" from "service_role";

revoke select on table "public"."product_comments" from "service_role";

revoke trigger on table "public"."product_comments" from "service_role";

revoke truncate on table "public"."product_comments" from "service_role";

revoke update on table "public"."product_comments" from "service_role";

revoke delete on table "public"."product_images" from "anon";

revoke insert on table "public"."product_images" from "anon";

revoke references on table "public"."product_images" from "anon";

revoke select on table "public"."product_images" from "anon";

revoke trigger on table "public"."product_images" from "anon";

revoke truncate on table "public"."product_images" from "anon";

revoke update on table "public"."product_images" from "anon";

revoke delete on table "public"."product_images" from "authenticated";

revoke insert on table "public"."product_images" from "authenticated";

revoke references on table "public"."product_images" from "authenticated";

revoke select on table "public"."product_images" from "authenticated";

revoke trigger on table "public"."product_images" from "authenticated";

revoke truncate on table "public"."product_images" from "authenticated";

revoke update on table "public"."product_images" from "authenticated";

revoke delete on table "public"."product_images" from "service_role";

revoke insert on table "public"."product_images" from "service_role";

revoke references on table "public"."product_images" from "service_role";

revoke select on table "public"."product_images" from "service_role";

revoke trigger on table "public"."product_images" from "service_role";

revoke truncate on table "public"."product_images" from "service_role";

revoke update on table "public"."product_images" from "service_role";

revoke delete on table "public"."products" from "anon";

revoke insert on table "public"."products" from "anon";

revoke references on table "public"."products" from "anon";

revoke select on table "public"."products" from "anon";

revoke trigger on table "public"."products" from "anon";

revoke truncate on table "public"."products" from "anon";

revoke update on table "public"."products" from "anon";

revoke delete on table "public"."products" from "authenticated";

revoke insert on table "public"."products" from "authenticated";

revoke references on table "public"."products" from "authenticated";

revoke select on table "public"."products" from "authenticated";

revoke trigger on table "public"."products" from "authenticated";

revoke truncate on table "public"."products" from "authenticated";

revoke update on table "public"."products" from "authenticated";

revoke delete on table "public"."products" from "service_role";

revoke insert on table "public"."products" from "service_role";

revoke references on table "public"."products" from "service_role";

revoke select on table "public"."products" from "service_role";

revoke trigger on table "public"."products" from "service_role";

revoke truncate on table "public"."products" from "service_role";

revoke update on table "public"."products" from "service_role";

revoke delete on table "public"."profiles" from "anon";

revoke insert on table "public"."profiles" from "anon";

revoke references on table "public"."profiles" from "anon";

revoke select on table "public"."profiles" from "anon";

revoke trigger on table "public"."profiles" from "anon";

revoke truncate on table "public"."profiles" from "anon";

revoke update on table "public"."profiles" from "anon";

revoke delete on table "public"."profiles" from "authenticated";

revoke insert on table "public"."profiles" from "authenticated";

revoke references on table "public"."profiles" from "authenticated";

revoke select on table "public"."profiles" from "authenticated";

revoke trigger on table "public"."profiles" from "authenticated";

revoke truncate on table "public"."profiles" from "authenticated";

revoke update on table "public"."profiles" from "authenticated";

revoke delete on table "public"."profiles" from "service_role";

revoke insert on table "public"."profiles" from "service_role";

revoke references on table "public"."profiles" from "service_role";

revoke select on table "public"."profiles" from "service_role";

revoke trigger on table "public"."profiles" from "service_role";

revoke truncate on table "public"."profiles" from "service_role";

revoke update on table "public"."profiles" from "service_role";

revoke delete on table "public"."provinces" from "anon";

revoke insert on table "public"."provinces" from "anon";

revoke references on table "public"."provinces" from "anon";

revoke select on table "public"."provinces" from "anon";

revoke trigger on table "public"."provinces" from "anon";

revoke truncate on table "public"."provinces" from "anon";

revoke update on table "public"."provinces" from "anon";

revoke delete on table "public"."provinces" from "authenticated";

revoke insert on table "public"."provinces" from "authenticated";

revoke references on table "public"."provinces" from "authenticated";

revoke select on table "public"."provinces" from "authenticated";

revoke trigger on table "public"."provinces" from "authenticated";

revoke truncate on table "public"."provinces" from "authenticated";

revoke update on table "public"."provinces" from "authenticated";

revoke delete on table "public"."provinces" from "service_role";

revoke insert on table "public"."provinces" from "service_role";

revoke references on table "public"."provinces" from "service_role";

revoke select on table "public"."provinces" from "service_role";

revoke trigger on table "public"."provinces" from "service_role";

revoke truncate on table "public"."provinces" from "service_role";

revoke update on table "public"."provinces" from "service_role";

revoke delete on table "public"."regencies" from "anon";

revoke insert on table "public"."regencies" from "anon";

revoke references on table "public"."regencies" from "anon";

revoke select on table "public"."regencies" from "anon";

revoke trigger on table "public"."regencies" from "anon";

revoke truncate on table "public"."regencies" from "anon";

revoke update on table "public"."regencies" from "anon";

revoke delete on table "public"."regencies" from "authenticated";

revoke insert on table "public"."regencies" from "authenticated";

revoke references on table "public"."regencies" from "authenticated";

revoke select on table "public"."regencies" from "authenticated";

revoke trigger on table "public"."regencies" from "authenticated";

revoke truncate on table "public"."regencies" from "authenticated";

revoke update on table "public"."regencies" from "authenticated";

revoke delete on table "public"."regencies" from "service_role";

revoke insert on table "public"."regencies" from "service_role";

revoke references on table "public"."regencies" from "service_role";

revoke select on table "public"."regencies" from "service_role";

revoke trigger on table "public"."regencies" from "service_role";

revoke truncate on table "public"."regencies" from "service_role";

revoke update on table "public"."regencies" from "service_role";

revoke delete on table "public"."reports" from "anon";

revoke insert on table "public"."reports" from "anon";

revoke references on table "public"."reports" from "anon";

revoke select on table "public"."reports" from "anon";

revoke trigger on table "public"."reports" from "anon";

revoke truncate on table "public"."reports" from "anon";

revoke update on table "public"."reports" from "anon";

revoke delete on table "public"."reports" from "authenticated";

revoke insert on table "public"."reports" from "authenticated";

revoke references on table "public"."reports" from "authenticated";

revoke select on table "public"."reports" from "authenticated";

revoke trigger on table "public"."reports" from "authenticated";

revoke truncate on table "public"."reports" from "authenticated";

revoke update on table "public"."reports" from "authenticated";

revoke delete on table "public"."reports" from "service_role";

revoke insert on table "public"."reports" from "service_role";

revoke references on table "public"."reports" from "service_role";

revoke select on table "public"."reports" from "service_role";

revoke trigger on table "public"."reports" from "service_role";

revoke truncate on table "public"."reports" from "service_role";

revoke update on table "public"."reports" from "service_role";

revoke delete on table "public"."trash_products" from "anon";

revoke insert on table "public"."trash_products" from "anon";

revoke references on table "public"."trash_products" from "anon";

revoke select on table "public"."trash_products" from "anon";

revoke trigger on table "public"."trash_products" from "anon";

revoke truncate on table "public"."trash_products" from "anon";

revoke update on table "public"."trash_products" from "anon";

revoke delete on table "public"."trash_products" from "authenticated";

revoke insert on table "public"."trash_products" from "authenticated";

revoke references on table "public"."trash_products" from "authenticated";

revoke select on table "public"."trash_products" from "authenticated";

revoke trigger on table "public"."trash_products" from "authenticated";

revoke truncate on table "public"."trash_products" from "authenticated";

revoke update on table "public"."trash_products" from "authenticated";

revoke delete on table "public"."trash_products" from "service_role";

revoke insert on table "public"."trash_products" from "service_role";

revoke references on table "public"."trash_products" from "service_role";

revoke select on table "public"."trash_products" from "service_role";

revoke trigger on table "public"."trash_products" from "service_role";

revoke truncate on table "public"."trash_products" from "service_role";

revoke update on table "public"."trash_products" from "service_role";

revoke delete on table "public"."view_history" from "anon";

revoke insert on table "public"."view_history" from "anon";

revoke references on table "public"."view_history" from "anon";

revoke select on table "public"."view_history" from "anon";

revoke trigger on table "public"."view_history" from "anon";

revoke truncate on table "public"."view_history" from "anon";

revoke update on table "public"."view_history" from "anon";

revoke delete on table "public"."view_history" from "authenticated";

revoke insert on table "public"."view_history" from "authenticated";

revoke references on table "public"."view_history" from "authenticated";

revoke select on table "public"."view_history" from "authenticated";

revoke trigger on table "public"."view_history" from "authenticated";

revoke truncate on table "public"."view_history" from "authenticated";

revoke update on table "public"."view_history" from "authenticated";

revoke delete on table "public"."view_history" from "service_role";

revoke insert on table "public"."view_history" from "service_role";

revoke references on table "public"."view_history" from "service_role";

revoke select on table "public"."view_history" from "service_role";

revoke trigger on table "public"."view_history" from "service_role";

revoke truncate on table "public"."view_history" from "service_role";

revoke update on table "public"."view_history" from "service_role";

alter table "public"."products" drop constraint "products_condition_check";

alter table "public"."profiles" drop constraint "profiles_role_check";

alter table "public"."categories" enable row level security;

alter table "public"."provinces" enable row level security;

alter table "public"."regencies" enable row level security;

alter table "public"."products" add constraint "products_condition_check" CHECK (((condition)::text = ANY ((ARRAY['Baru'::character varying, 'Seperti Baru'::character varying, 'Sangat Bagus'::character varying, 'Bagus'::character varying, 'Cukup Bagus'::character varying])::text[]))) not valid;

alter table "public"."products" validate constraint "products_condition_check";

alter table "public"."profiles" add constraint "profiles_role_check" CHECK (((role)::text = ANY ((ARRAY['user'::character varying, 'admin'::character varying, 'moderator'::character varying])::text[]))) not valid;

alter table "public"."profiles" validate constraint "profiles_role_check";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.archive_old_inactive_products()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE products
  SET status = 'deleted'
  WHERE status = 'inactive'
    AND updated_at < now() - INTERVAL '90 days';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_admin()
 RETURNS TABLE(user_id uuid, email text, full_name text, role text, is_admin boolean)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    u.email::TEXT,
    p.full_name,
    p.role,
    (p.role = 'admin') as is_admin
  FROM profiles p
  JOIN auth.users u ON p.id = u.id
  WHERE p.id = auth.uid();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_access_logs()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  DELETE FROM access_logs
  WHERE created_at < NOW() - INTERVAL '90 days';
END;
$function$
;

CREATE OR REPLACE FUNCTION public.cleanup_old_view_history()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  DELETE FROM view_history
  WHERE id IN (
    SELECT id FROM (
      SELECT id, ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY viewed_at DESC) as rn
      FROM view_history
    ) t
    WHERE rn > 100
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.find_nearest_regency(lat numeric, lng numeric)
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  nearest_regency_id INTEGER;
BEGIN
  SELECT regency_id INTO nearest_regency_id
  FROM regencies
  WHERE latitude IS NOT NULL AND longitude IS NOT NULL
  ORDER BY (
    6371 * acos(
      cos(radians(lat)) *
      cos(radians(latitude)) *
      cos(radians(longitude) - radians(lng)) +
      sin(radians(lat)) *
      sin(radians(latitude))
    )
  ) ASC
  LIMIT 1;

  RETURN nearest_regency_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_all_admins()
 RETURNS TABLE(user_id uuid, email text, full_name text, role text, created_at timestamp with time zone)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    u.email::TEXT,
    p.full_name,
    p.role,
    p.created_at
  FROM profiles p
  JOIN auth.users u ON p.id = u.id
  WHERE p.role = 'admin'
  ORDER BY p.created_at;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_all_users_with_email()
 RETURNS TABLE(id uuid, email text, full_name text, username text, avatar_url text, bio text, role text, created_at timestamp with time zone, is_suspended boolean)
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
AS $function$
BEGIN
  -- Only admins can call this function
  IF NOT EXISTS (
    SELECT 1 FROM profiles
    WHERE profiles.id = auth.uid()
    AND profiles.role = 'admin'
  ) THEN
    RAISE EXCEPTION 'Access denied. Admin role required.';
  END IF;

  RETURN QUERY
  SELECT
    p.id,
    u.email::TEXT,
    p.full_name::TEXT,
    p.username::TEXT,
    p.avatar_url::TEXT,
    p.bio::TEXT,
    p.role::TEXT,
    p.created_at,
    COALESCE(p.is_suspended, false) as is_suspended
  FROM profiles p
  JOIN auth.users u ON p.id = u.id
  ORDER BY p.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_comment_replies(comment_uuid uuid)
 RETURNS TABLE(id uuid, product_id uuid, user_id uuid, parent_id uuid, comment text, rating integer, created_at timestamp with time zone, updated_at timestamp with time zone, is_seller_reply boolean, user_name text, user_avatar text)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    c.id,
    c.product_id,
    c.user_id,
    c.parent_id,
    c.comment,
    c.rating,
    c.created_at,
    c.updated_at,
    c.is_seller_reply,
    COALESCE(p.full_name, p.username, 'Anonymous') as user_name,
    p.avatar_url as user_avatar
  FROM product_comments c
  LEFT JOIN profiles p ON c.user_id = p.id
  WHERE c.parent_id = comment_uuid
  ORDER BY c.created_at ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_product_comment_stats(product_uuid uuid)
 RETURNS TABLE(comment_count bigint, average_rating numeric, rating_distribution jsonb)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*)::BIGINT as comment_count,
    ROUND(AVG(rating), 1) as average_rating,
    jsonb_object_agg(
      rating::TEXT,
      rating_count
    ) as rating_distribution
  FROM (
    SELECT
      rating,
      COUNT(*) as rating_count
    FROM product_comments
    WHERE product_id = product_uuid
      AND rating IS NOT NULL
      AND parent_id IS NULL
    GROUP BY rating
  ) rating_counts;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_product_comments_with_replies(product_uuid uuid)
 RETURNS TABLE(id uuid, product_id uuid, user_id uuid, parent_id uuid, comment text, rating integer, created_at timestamp with time zone, updated_at timestamp with time zone, is_seller_reply boolean, user_name text, user_avatar text, reply_count bigint)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    c.id,
    c.product_id,
    c.user_id,
    c.parent_id,
    c.comment,
    c.rating,
    c.created_at,
    c.updated_at,
    c.is_seller_reply,
    COALESCE(p.full_name, p.username, 'Anonymous') as user_name,
    p.avatar_url as user_avatar,
    (
      SELECT COUNT(*)
      FROM product_comments replies
      WHERE replies.parent_id = c.id
    )::BIGINT as reply_count
  FROM product_comments c
  LEFT JOIN profiles p ON c.user_id = p.id
  WHERE c.product_id = product_uuid
    AND c.parent_id IS NULL
  ORDER BY c.created_at DESC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_product_stats(user_uuid uuid)
 RETURNS TABLE(total_products bigint, active_products bigint, sold_products bigint, total_favorites bigint, average_rating numeric)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*) FILTER (WHERE status != 'deleted')::BIGINT as total_products,
    COUNT(*) FILTER (WHERE status = 'active')::BIGINT as active_products,
    COUNT(*) FILTER (WHERE status = 'sold')::BIGINT as sold_products,
    (SELECT COUNT(*) FROM favorites WHERE favorites.user_id = user_uuid)::BIGINT as total_favorites,
    (
      SELECT ROUND(AVG(rating), 1)
      FROM product_comments c
      JOIN products p ON c.product_id = p.id
      WHERE p.user_id = user_uuid
        AND c.rating IS NOT NULL
        AND c.parent_id IS NULL
    ) as average_rating
  FROM products
  WHERE user_id = user_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.profiles (id, username, full_name, avatar_url)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'username', NULL),
    COALESCE(NEW.raw_user_meta_data->>'full_name', NULL),
    COALESCE(NEW.raw_user_meta_data->>'avatar_url', NULL)
  );
  RETURN NEW;
EXCEPTION
  WHEN unique_violation THEN
    -- 이미 존재하면 업데이트
    UPDATE public.profiles
    SET
      username = COALESCE(NEW.raw_user_meta_data->>'username', username),
      full_name = COALESCE(NEW.raw_user_meta_data->>'full_name', full_name),
      avatar_url = COALESCE(NEW.raw_user_meta_data->>'avatar_url', avatar_url)
    WHERE id = NEW.id;
    RETURN NEW;
  WHEN others THEN
    -- 에러 로그 남기고 계속 진행
    RAISE WARNING 'Error creating profile for user %: %', NEW.id, SQLERRM;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_admin()
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid()
    AND role = 'admin'
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.move_user_products_to_trash(target_user_id uuid, admin_user_id uuid, reason text)
 RETURNS TABLE(moved_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  product_record RECORD;
  total_moved integer := 0;
  user_email_val text;
  user_name_val text;
BEGIN
  -- Verify admin permission
  IF NOT EXISTS (
    SELECT 1 FROM profiles
    WHERE id = admin_user_id
    AND role = 'admin'
  ) THEN
    RAISE EXCEPTION 'Admin permission required';
  END IF;

  -- Get user info
  SELECT u.email, p.full_name
  INTO user_email_val, user_name_val
  FROM auth.users u
  LEFT JOIN profiles p ON u.id = p.id
  WHERE u.id = target_user_id;

  -- Loop through all products of the user
  FOR product_record IN
    SELECT
      p.*,
      COALESCE(
        jsonb_agg(
          DISTINCT jsonb_build_object(
            'image_url', pi.image_url,
            'order', pi.order
          )
        ) FILTER (WHERE pi.id IS NOT NULL),
        '[]'::jsonb
      ) as product_images,
      COALESCE(
        jsonb_agg(
          DISTINCT jsonb_build_object(
            'id', pc.id,
            'user_id', pc.user_id,
            'comment', pc.comment,
            'rating', pc.rating,
            'created_at', pc.created_at,
            'is_seller_reply', pc.is_seller_reply
          )
        ) FILTER (WHERE pc.id IS NOT NULL),
        '[]'::jsonb
      ) as product_comments
    FROM products p
    LEFT JOIN product_images pi ON p.id = pi.product_id
    LEFT JOIN product_comments pc ON p.id = pc.product_id
    WHERE p.user_id = target_user_id
    GROUP BY p.id
  LOOP
    -- Insert to trash
    INSERT INTO trash_products (
      original_product_id,
      user_id,
      user_email,
      user_full_name,
      title,
      description,
      price,
      condition,
      is_negotiable,
      status,
      province_id,
      regency_id,
      latitude,
      longitude,
      category_id,
      images,
      comments,
      created_at,
      deleted_at,
      deleted_by,
      deletion_reason
    ) VALUES (
      product_record.id,
      product_record.user_id,
      user_email_val,
      user_name_val,
      product_record.title,
      product_record.description,
      product_record.price,
      product_record.condition,
      product_record.is_negotiable,
      product_record.status,
      product_record.province_id,
      product_record.regency_id,
      product_record.latitude,
      product_record.longitude,
      product_record.category_id,
      product_record.product_images,
      product_record.product_comments,
      product_record.created_at,
      now(),
      admin_user_id,
      reason
    );

    total_moved := total_moved + 1;
  END LOOP;

  RETURN QUERY SELECT total_moved;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.nearby_products(user_lat numeric, user_lng numeric, max_distance_km integer DEFAULT 50, limit_count integer DEFAULT 50)
 RETURNS TABLE(id uuid, title character varying, description text, price integer, condition character varying, is_negotiable boolean, status character varying, province_id integer, regency_id integer, latitude numeric, longitude numeric, category_id integer, created_at timestamp with time zone, updated_at timestamp with time zone, phone_number character varying, whatsapp_number character varying, distance_km numeric, image_url text, regency_name character varying, province_name character varying, category_name character varying)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.title,
    p.description,
    p.price,
    p.condition,
    p.is_negotiable,
    p.status,
    p.province_id,
    p.regency_id,
    p.latitude,
    p.longitude,
    p.category_id,
    p.created_at,
    p.updated_at,
    p.phone_number,
    p.whatsapp_number,
    (6371 * acos(
      cos(radians(user_lat)) *
      cos(radians(p.latitude)) *
      cos(radians(p.longitude) - radians(user_lng)) +
      sin(radians(user_lat)) *
      sin(radians(p.latitude))
    ))::DECIMAL AS distance_km,
    (SELECT pi.image_url FROM product_images pi WHERE pi.product_id = p.id ORDER BY pi.order ASC LIMIT 1) AS image_url,
    r.regency_name,
    pr.province_name,
    c.name AS category_name
  FROM products p
  LEFT JOIN regencies r ON p.regency_id = r.regency_id
  LEFT JOIN provinces pr ON r.province_id = pr.province_id
  LEFT JOIN categories c ON p.category_id = c.category_id
  WHERE
    p.status = 'active'
    AND p.latitude IS NOT NULL
    AND p.longitude IS NOT NULL
    AND (6371 * acos(
      cos(radians(user_lat)) *
      cos(radians(p.latitude)) *
      cos(radians(p.longitude) - radians(user_lng)) +
      sin(radians(user_lat)) *
      sin(radians(p.latitude))
    )) <= max_distance_km
  ORDER BY distance_km ASC
  LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.products_by_regency(user_regency_id integer, limit_count integer DEFAULT 20)
 RETURNS TABLE(id uuid, title text, price integer, description text, condition text, status text, user_id uuid, regency_id integer, category_id integer, latitude numeric, longitude numeric, created_at timestamp with time zone)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.title,
    p.price,
    p.description,
    p.condition,
    p.status,
    p.user_id,
    p.regency_id,
    p.category_id,
    p.latitude,
    p.longitude,
    p.created_at
  FROM products p
  WHERE p.status = 'active'
    AND (
      p.regency_id = user_regency_id
      OR p.regency_id IN (
        SELECT r2.regency_id
        FROM regencies r1
        JOIN regencies r2 ON r1.province_id = r2.province_id
        WHERE r1.regency_id = user_regency_id
      )
    )
  ORDER BY
    CASE WHEN p.regency_id = user_regency_id THEN 0 ELSE 1 END,
    p.created_at DESC
  LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.products_search_vector_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.search_vector := to_tsvector('indonesian', coalesce(NEW.title, '') || ' ' || coalesce(NEW.description, ''));
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.restore_product_from_trash(trash_id uuid, admin_user_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  trash_record RECORD;
  new_product_id uuid;
  image_item jsonb;
  comment_item jsonb;
BEGIN
  -- Verify admin permission
  IF NOT EXISTS (
    SELECT 1 FROM profiles
    WHERE id = admin_user_id
    AND role = 'admin'
  ) THEN
    RAISE EXCEPTION 'Admin permission required';
  END IF;

  -- Get trash record
  SELECT * INTO trash_record
  FROM trash_products
  WHERE id = trash_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Trash record not found';
  END IF;

  -- Check if user still exists
  IF NOT EXISTS (SELECT 1 FROM profiles WHERE id = trash_record.user_id) THEN
    RAISE EXCEPTION 'Cannot restore: User no longer exists';
  END IF;

  -- Restore product
  INSERT INTO products (
    user_id,
    title,
    description,
    price,
    condition,
    is_negotiable,
    status,
    province_id,
    regency_id,
    latitude,
    longitude,
    category_id,
    created_at,
    updated_at
  ) VALUES (
    trash_record.user_id,
    trash_record.title,
    trash_record.description,
    trash_record.price,
    trash_record.condition,
    trash_record.is_negotiable,
    'inactive', -- Restore as inactive for review
    trash_record.province_id,
    trash_record.regency_id,
    trash_record.latitude,
    trash_record.longitude,
    trash_record.category_id,
    trash_record.created_at,
    now()
  )
  RETURNING id INTO new_product_id;

  -- Restore images
  FOR image_item IN SELECT * FROM jsonb_array_elements(trash_record.images)
  LOOP
    INSERT INTO product_images (product_id, image_url, "order")
    VALUES (
      new_product_id,
      (image_item->>'image_url')::text,
      (image_item->>'order')::integer
    );
  END LOOP;

  -- Note: Comments are not restored, kept in trash for evidence only

  -- Delete from trash
  DELETE FROM trash_products WHERE id = trash_id;

  RETURN new_product_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_products(search_query text, limit_count integer DEFAULT 50)
 RETURNS TABLE(id uuid, title text, description text, price integer, condition text, status text, latitude numeric, longitude numeric, regency_id integer, category_id integer, user_id uuid, created_at timestamp with time zone, rank real)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.title,
    p.description,
    p.price,
    p.condition,
    p.status,
    p.latitude,
    p.longitude,
    p.regency_id,
    p.category_id,
    p.user_id,
    p.created_at,
    ts_rank(p.search_vector, to_tsquery('indonesian', search_query)) as rank
  FROM products p
  WHERE p.search_vector @@ to_tsquery('indonesian', search_query)
    AND p.status = 'active'
  ORDER BY rank DESC, p.created_at DESC
  LIMIT limit_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_access_log_regency()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
BEGIN
  IF NEW.latitude IS NOT NULL AND NEW.longitude IS NOT NULL AND NEW.regency_id IS NULL THEN
    NEW.regency_id := find_nearest_regency(NEW.latitude, NEW.longitude);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_product_location_from_regency()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF (NEW.latitude IS NULL OR NEW.longitude IS NULL) AND NEW.regency_id IS NOT NULL THEN
    SELECT latitude, longitude
    INTO NEW.latitude, NEW.longitude
    FROM regencies
    WHERE regency_id = NEW.regency_id;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_product_comments_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_reports_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_view_history(p_user_id uuid, p_product_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO view_history (user_id, product_id, viewed_at)
  VALUES (p_user_id, p_product_id, now())
  ON CONFLICT (user_id, product_id)
  DO UPDATE SET viewed_at = now();
END;
$function$
;

create policy "Public Read Access for categories"
on "public"."categories"
as permissive
for select
to public
using (true);


create policy "Public Read Access for provinces"
on "public"."provinces"
as permissive
for select
to public
using (true);


create policy "Public Read Access for regencies"
on "public"."regencies"
as permissive
for select
to public
using (true);



